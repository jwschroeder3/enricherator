functions {
    // Taken straight from stan code generated by brms
    /* Efficient computation of the horseshoe prior
        * see Appendix C.1 in https://projecteuclid.org/euclid.ejs/1513306866
        * Args:
        *   z: standardized population-level coefficients
        *   lambda: local shrinkage parameters
        *   tau: global shrinkage parameter
        *   c2: slab regularization parameter
        * Returns:
        *   population-level coefficients following the horseshoe prior
    */
    vector horseshoe(vector z, vector lambda, real tau, real c2) {
        int K = rows(z);
        vector[K] lambda2 = square(lambda);
        vector[K] lambda_tilde = sqrt(c2 * lambda2 ./ (c2 + tau^2 * lambda2));
        return z .* lambda_tilde * tau;
    }
    
}

data {
    int<lower=1> L; // number of positions
    //int<lower=1> a_C; // correlation distance (in positions, not basepairs)
    //int<lower=1> b_C; // correlation distance (in positions, not basepairs)
    int<lower=1> S; // number of samples
    int<lower=1> B; // number of betas
    int<lower=1> A; // number of alphas
    int<lower=1> G; // number of genotypes
    int<lower=1, upper=2> Q; // number of strands
    real alpha_prior;
    array[S] int geno_x; // genotype for each sample
    array[S] int sample_x; // sample_id for each datum
    array[S,Q,L] int Y; // counts
    array[S] real<lower=0> libsize; // exposure term for each sample
    real<lower=0> hs_df; // local df
    real<lower=0> hs_df_global; // global df
    real<lower=0> hs_df_slab; // slab df
    real<lower=0> hs_scale_global; // global prior scale
    real<lower=0> hs_scale_slab; // slab prior scale
    //int<lower=1> gauss_dist;
    int<lower=1> a_sub_L;
    int<lower=1> b_sub_L;
    int<lower=1> b_num_non_zero;
    vector<lower=0,upper=1>[b_num_non_zero] b_weights_vals;
    array[b_num_non_zero] int b_col_accessor;
    array[L+1] int b_row_non_zero_number;
    int<lower=1> a_num_non_zero;
    vector<lower=0,upper=1>[a_num_non_zero] a_weights_vals;
    array[a_num_non_zero] int a_col_accessor;
    array[L+1] int a_row_non_zero_number;
    int<lower=0, upper=1> gather_log_lik;
}

transformed data {
    array[S] real cent_loglibsize;
    int N = L*Q*S;
    int num_hs = b_sub_L*B*Q;
    {
        array[S] real log_libsize;
        real mean_loglib;
        for (s in 1:S) {
            log_libsize[s] = log(libsize[s]);
        }
        mean_loglib = mean(log_libsize);
        for (s in 1:S) {
            cent_loglibsize[s] = log_libsize[s] - mean_loglib;
        }
    }
}

parameters {
    vector<lower=0>[2] prec; // stratify global precision inference by extracted vs input
    array[G,Q] vector[a_sub_L] sub_Alpha; // one intercept for each genotype/sub-position
    vector[B] Gamma; // an intercept to offset hbd samples by

    // parameters for hyperlasso shrinkage prior
    array[B,Q] vector[b_sub_L] sub_Beta;
    array[B,Q] vector<lower=0>[b_sub_L] sub_beta_sig;
    array[B,Q] vector<lower=0>[b_sub_L] sig_scale;
    real<lower=0> lambda;

    //// local parameters for horseshoe prior
    //array[B,Q] vector[b_sub_L] zbeta;
    //array[B,Q] vector<lower=0>[b_sub_L] hs_local;
    //// horseshoe shrinkage parameters 
    //real<lower=0> hs_global; 
    //real<lower=0> hs_slab; 
    //real<lower=0> shape; 
}

transformed parameters {
    array[B,Q] vector[L] Beta;
    array[G,Q] vector[L] Alpha; // one intercept for each genotype/position combination

    real lprior = 0.0;

    {
        vector[L] tmp_Beta;
        //vector[b_sub_L] sub_Beta;
        for (b in 1:B) {
            for (q in 1:Q) {
                //print(sub_Beta[1:5])
                tmp_Beta = csr_matrix_times_vector(
                    L,
                    b_sub_L,
                    b_weights_vals,
                    b_col_accessor,
                    b_row_non_zero_number,
                    sub_Beta[b,q]
                );
                Beta[b,q] = tmp_Beta + Gamma[b];
            }
        }
    }

    for (g in 1:G) {
        for (q in 1:Q) {
            Alpha[g,q] = csr_matrix_times_vector(
                L,
                a_sub_L,
                a_weights_vals,
                a_col_accessor,
                a_row_non_zero_number,
                sub_Alpha[g,q]
            );
        }
    }

    lprior += cauchy_lpdf(prec | 0, 1);
    lprior += cauchy_lpdf(lambda | 0, 1);

    {
        vector[b_sub_L] inv_scale;
        real inv_lamsq = 1.0 / ( lambda * lambda );
        for (b in 1:B) {
            for (q in 1:Q) {
                lprior += gamma_lpdf(sig_scale[b,q] | 0.5, inv_lamsq);
                inv_scale = 1 ./ sig_scale[b,q];
                lprior += exponential_lpdf(sub_beta_sig[b,q] | inv_scale);
                lprior += normal_lpdf(sub_Beta[b,q] | 0, sub_beta_sig[b,q]);
            }
        }
    }

    for (g in 1:B) {
        for (q in 1:Q) {
            lprior += normal_lpdf(sub_Alpha[g,q] | alpha_prior, 4);
        }
    }

    lprior += student_t_lpdf(Gamma | 3, 0, 5);
}

model {
    int grainsize = 1;
    int sample_type;
    int genotype;
    vector[L] Y_hat_sq;

    target += lprior;

    for (s in 1:S) {
        sample_type = sample_x[s];
        genotype = geno_x[s];
        for (q in 1:Q) {
            Y_hat_sq = Alpha[genotype,q]
                + sample_type * Beta[genotype,q]
                + cent_loglibsize[s];
            target += neg_binomial_2_log_lpmf(Y[s,q] | Y_hat_sq, prec[sample_type+1]);
        }
    }
}

//generated quantities {
//    vector[N] log_lik;
//    array[S,Q] vector[L] post_pred;
//    {
//        vector[L] Y_hat_sq;
//        int n = 1;
//        int genotype;
//        int sample_type;
//        if (gather_log_lik) {
//            for (s in 1:S) {
//                sample_type = sample_x[s];
//                genotype = geno_x[s];
//                for (q in 1:Q) {
//                    Y_hat_sq = Alpha[genotype,q]
//                        + sample_type * Beta[genotype,q]
//                        + cent_loglibsize[s];
//                    for (l in 1:L) {
//                        post_pred[s,q][l] = neg_binomial_2_rng(exp(Y_hat_sq[l]), prec[sample_type+1]);
//                        log_lik[n] = neg_binomial_2_log_lpmf(Y[s,q,l] | Y_hat_sq[l], prec[sample_type+1]);
//                        n += 1;
//                    }
//                }
//            }
//        }
//    }
//}

