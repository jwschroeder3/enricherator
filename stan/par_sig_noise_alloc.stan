functions {
    // Taken straight from stan code generated by brms
    /* Efficient computation of the horseshoe prior
        * see Appendix C.1 in https://projecteuclid.org/euclid.ejs/1513306866
        * Args:
        *   z: standardized population-level coefficients
        *   lambda: local shrinkage parameters
        *   tau: global shrinkage parameter
        *   c2: slab regularization parameter
        * Returns:
        *   population-level coefficients following the horseshoe prior
    */
    vector horseshoe(vector z, vector lambda, real tau, real c2) {
        int K = rows(z);
        vector[K] lambda2 = square(lambda);
        // eq 2.8 in piironen and vehtari
        vector[K] lambda_tilde = sqrt(c2 * lambda2 ./ (c2 + tau^2 * lambda2));
        return z .* lambda_tilde * tau;
    }

    /* For parallel mapping of likelihood calculation
        * Args:
        *   phi: parameters common across all jobs, should be shape (2 + 4*S + G*Q*2*S)
        *   theta: parameters local to each job, y_hat
        *   x_r: will not be used
        *   x_i: the counts, sample_type array of length 2
    */
    vector map_loglik(
            vector phi,
            vector theta,
            array[] real x_r,
            array[] int x_i
    ) {

        real y_hat;
        real ll = 0.0;

        // first element of phi is S
        int S = x_i[1];
        // second element of phi is covar_num
        int covar_num = x_i[2];

        int start = 1;
        int end = start + S - 1;
        // grab precisions
        vector[S] precision = phi[start:end];
        start += S;
        end += S;
        // grab signoise
        vector[S] log_signoise = phi[start:end];
        start += S;
        end += S;
        // grab complement of signoise
        vector[S] log_comp_signoise = phi[start:end];
        start += S;
        end += S;

        // grab libsize
        vector[S] libsize = phi[start:end];
        start += S;
        end = start + covar_num - 1;

        for (s in 1:S) {
            // phi[start:end] is a vector of indicators for this sample
            // theta is a vector of alphas and betas
            // x_r[s] is the log-libsize for this sample
            y_hat = dot_product(phi[start:end], theta) + libsize[s];
            ll += log_sum_exp(
                log_signoise[s] + neg_binomial_2_log_lpmf(x_i[2 + s] | y_hat, precision[s]),
                log_comp_signoise[s] + poisson_log_lpmf(x_i[2 + s] | libsize[s])
            );
            start += covar_num;
            end += covar_num;
        }

        return [ll]';
    }
}

data {
    int<lower=1> N; // number of observations: L*Q*S;
    int<lower=1> L; // number of positions
    int<lower=1> S; // number of samples
    int<lower=1> B; // number of betas
    int<lower=1> A; // number of alphas
    int<lower=1> G; // number of genotypes
    int<lower=1, upper=2> Q; // number of strands

    real alpha_prior;

    array[S] int geno_x; // genotype for each sample
    array[S] int sample_x; // sample_id for each sample
    array[S] int strand_x; // sample_id for each sample
    //array[S] real<lower=0> libsize; // exposure term for each sample

    array[L,2+S] int X_i; // for each genome position, the count for each sample
    array[L,1] real X_r; // ends up being ignored but has to exist for map_rect to work

    vector[S] cent_loglibsize;

    real<lower=0> hs_df; // local df
    real<lower=0> hs_df_global; // global df
    real<lower=0> hs_df_slab; // slab df
    real<lower=0> hs_scale_global; // global prior scale
    real<lower=0> hs_scale_slab; // slab prior scale

    int<lower=1> a_sub_L;
    int<lower=1> b_sub_L;
    int<lower=1> b_num_non_zero;
    vector<lower=0,upper=1>[b_num_non_zero] b_weights_vals;
    array[b_num_non_zero] int b_col_accessor;
    array[L+1] int b_row_non_zero_number;
    int<lower=1> a_num_non_zero;
    vector<lower=0,upper=1>[a_num_non_zero] a_weights_vals;
    array[a_num_non_zero] int a_col_accessor;
    array[L+1] int a_row_non_zero_number;

    //int<lower=0, upper=1> gather_log_lik;
}

transformed data {
    //array[S] real cent_loglibsize;
    int num_hs = b_sub_L*B*Q;
    array[S] vector[G*Q*2] indicators;

    {
        int strand;
        int geno;
        int samp_type;
        int beta_idx;
        int alpha_idx;
        int q_offset;
        int g_offset;
        int covar_num = G*Q*2;

        for (s in 1:S) {

            vector[covar_num] samp_covars = rep_vector(0, covar_num);

            strand = strand_x[s];
            q_offset = (strand - 1) * 2;
            geno = geno_x[s];
            g_offset = (geno - 1) * 2 * Q;
            samp_type = sample_x[s];

            alpha_idx = g_offset + q_offset + 1;
            beta_idx = alpha_idx + 1;

            if (samp_type == 1) {
                samp_covars[beta_idx] = 1;
            }
            samp_covars[alpha_idx] = 1;

            indicators[s] = samp_covars;
        }
    }

}

parameters {
    vector<lower=0, upper=1>[S] sig_noise; // signal-to-noise allocation for each sample
    //vector[S] wsh; // wsh term for how much wsh for a given sample
    vector<lower=0>[2] prec; // stratify global precision inference by extracted vs input
    array[G,Q] vector[a_sub_L] sub_Alpha; // one intercept for each genotype/sub-position
    //array[B,Q] vector[b_sub_L] sub_Beta; // one beta for each genotype/sub-position
    vector[B] Gamma; // an intercept to offset hbd samples by

    // local parameters for horseshoe prior
    array[B,Q] vector[b_sub_L] zbeta;
    array[B,Q] vector<lower=0>[b_sub_L] hs_local;
    // horseshoe shrinkage parameters 
    real<lower=0> hs_global; 
    real<lower=0> hs_slab; 
    real<lower=0> shape; 
}

transformed parameters {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// how might these be rearranged, or not, to get map_rect working?
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
    //array[B,Q] vector[L] Beta;
    //array[G,Q] vector[L] Alpha; // one intercept for each genotype/position combination
    array[L] vector[G*Q*2] Alpha_Beta;

    real lprior = 0.0;

    {
        int g_offset;
        int q_offset;
        int alpha_idx;
        int beta_idx;
        //array[B,Q] vector[b_sub_L] sub_Beta
        vector[b_sub_L] sub_Beta; // one intercept for each genotype/sub-position
        vector[L] tmp_Beta;
        vector[L] tmp_Alpha;
        for (g in 1:G) {
            g_offset = (g - 1) * 2 * Q;
            for (q in 1:Q) {
                tmp_Alpha = csr_matrix_times_vector(
                    L,
                    a_sub_L,
                    a_weights_vals,
                    a_col_accessor,
                    a_row_non_zero_number,
                    sub_Alpha[g,q]
                );
                sub_Beta = horseshoe(
                    zbeta[g,q],
                    hs_local[g,q],
                    hs_global,
                    hs_scale_slab^2 * hs_slab
                );
                tmp_Beta = csr_matrix_times_vector(
                    L,
                    b_sub_L,
                    b_weights_vals,
                    b_col_accessor,
                    b_row_non_zero_number,
                    sub_Beta
                );
                //Beta[g,q] = tmp_Beta + Gamma[g];
                tmp_Beta += Gamma[g];
                
                q_offset = (q - 1) * 2;
                // plus two for betas (see below for plus 1 for alphas)
                alpha_idx = g_offset + q_offset + 1;
                beta_idx = alpha_idx + 1;
                for (l in 1:L) {
                    Alpha_Beta[l][alpha_idx] = tmp_Alpha[l];
                    Alpha_Beta[l][beta_idx] = tmp_Beta[l];
                }
            }
        }
    }

    lprior += student_t_lpdf(hs_global | hs_df_global, 0, hs_scale_global)
        - 1 * log(0.5);
    lprior += inv_gamma_lpdf(hs_slab | 0.5 * hs_df_slab, 0.5 * hs_df_slab);
    lprior += gamma_lpdf(shape | 0.01, 0.01);

    for (b in 1:B) {
        for (q in 1:Q) {
            lprior += std_normal_lpdf(zbeta[b,q]);
            lprior += student_t_lpdf(hs_local[b,q] | hs_df, 0, 1)
              - num_hs * log(0.5);
        }
    }

    for (g in 1:B) {
        for (q in 1:Q) {
            lprior += normal_lpdf(sub_Alpha[g,q] | alpha_prior, 4);
        }
    }

    lprior += student_t_lpdf(Gamma | 3, 0, 5);
    lprior += beta_lpdf(sig_noise | 25.0, 1.0);
}

model {
    int sample_type;
    int genotype;
    // 4S for precision for each S, signoise for each S, comp_signoise for each S, libsize for each S
    // 2GQ * S because 2GQ is the number of parameters at each locus, for each S
    vector[4*S + G*Q*2*S] phi;
    array[N] vector[1] Y_hat_signal;
    //real Y_hat_noise;
    //real wsh_s;
    real libsize_s;
    real log_signoise_s;
    real log_comp_signoise_s;
    //int end_n;
    //int start_n = 1;
    vector[S] log_signoise = log(sig_noise);
    vector[S] log_comp_signoise = log1m(sig_noise);

    int covar_num = G*Q*2;

    int start = 1;
    int end = start + S - 1;

    target += lprior;

    prec ~ lognormal(0, 1);

    // fill phi with correct precisions
    for (s in 1:S) {
        phi[start + s - 1] = prec[sample_x[s] + 1];
    }

    start += S;
    end += S;

    // fill phi with log_signoise
    phi[start:end] = log_signoise;

    start += S;
    end += S;

    // fill phi with complement of signoise
    phi[start:end] = log_comp_signoise;

    start += S;
    end += S;

    // fill phi with libsize
    phi[start:end] = cent_loglibsize;

    start += S;
    end = start + covar_num - 1;

    // fill phi with indicator variables
    for (s in 1:S) {
        phi[start:end] = indicators[s];
        start += covar_num;
        end += covar_num;
    }

    /* Needs:
    1. ys - 2D array, N-by-something, each row will be passed to map_rect
    2. xs - 2D array, N-by-something, each row will be passed to map_rect
    3. global_params - 
    4. local_params - Y_hat_signal, array of real
    */
    target += sum(map_rect(map_loglik, phi, Alpha_Beta, X_r, X_i));
}

